Критично

  - Отсутствует аутентификация/авторизация на всех API и WS: любой клиент может отправлять телеметрию, стартовать
    симуляцию и читать позиции по orderId (backend/main.py:262–276, 336–354, 362–397). Это делает систему уязвимой к
    подмене маршрутов/доставок и утечкам.
  - Текущая авторизация через статический token + HMAC по orderId не подходит. Нужна полноценная JWT‑аутентификация
    (access/refresh, issuer/audience, exp/nbf, key rotation) и проверка ролей/скоупов на API и WS.
  - Состояние заказов и подписок держится только в памяти процесса; при рестарте или при нескольких воркерах состояние
    теряется/расходится (backend/main.py:132–138, 262–276). Масштабирование “вширь” ломает трекинг.
  - GET /drone/position запускает побочные эффекты (старт симуляции). Это нарушает идемпотентность и открывает путь к
    DDoS/накрутке задач простыми GET‑запросами (backend/main.py:336–354, 221–259).
  - Клиент не отправляет авторизационные заголовки (Authorization, X‑Order‑Token), поэтому все ключевые вызовы будут 401/403,
    фактически приложение не работает с включенной защитой (drone_app/lib/state/app_state.dart, drone_app/lib/utils/ws_client_*.dart).
  - Нет контракта выдачи и проверки order‑token/JWT для конкретного заказа: клиент генерирует orderId локально и не получает
    серверного подтверждения/подписанного токена. Нужен endpoint создания заказа и выдачи токена/claims на заказ.
  - Трекинг не запускается из клиента: WS‑сообщение start_tracking не запускает симуляцию на сервере, HTTP‑fallback не имеет
    телеметрии и получает 404. Нужна согласованная схема запуска и статуса заказа (backend/main.py, drone_app/lib/state/app_state.dart).

  Высокий

  - SQLite с check_same_thread=False без транзакционной дисциплины, без миграций и без внешних ключей/индексов; при
    нагрузке будут блокировки и гонки, масштабироваться нельзя (backend/main.py:33–90). Для продакшна нужен полноценный
    RDBMS и миграции.
  - CORS allow_origins=["*"] вместе с allow_credentials=True — небезопасно и в браузерах может блокироваться; открывает
    доступ к API со сторонних доменов (backend/main.py:122–127).
  - Геокодинг через public Nominatim без лимитов/квот/ключей и без ограничения объема кэша; риск блокировки и утечек
    памяти (backend/main.py:141–174, 279–307).
  - Полностью отсутствует защита канала: HTTP/WS без TLS по умолчанию, в приложении нет принуждения к HTTPS/WSS
    (drone_app/lib/state/app_state.dart:24–41). Это недопустимо для продакшна с доставкой.
  - Спецификация openapi.yaml не соответствует реальному backend: заявлены JWT/API‑Key и B2B endpoints, которых нет;
    геокодинг описан как public, но в коде защищен токеном. Это ломает интеграции и вводит в заблуждение.
  - Единый статический API token без ролей/скоупов и без ротации: компрометирует весь доступ сразу (backend/main.py).
  - Блокировки event loop: синхронные операции с SQLite внутри async‑эндпоинтов при нагрузке будут тормозить весь сервис.

  Средний

  - Нет валидации координат/прогресса/статуса; в систему можно передать некорректные данные и сломать логику (backend/
    main.py:110–117, 262–276, 336–354).
  - Нет персистентных заказов/событий: трекинг и “оплата” не фиксируются на сервере, нет идемпотентности, нет истории и
    аудита (drone_app/lib/state/app_state.dart:221–233).
  - Логи через print/debugPrint без уровней/корреляции/трассировки (backend/main.py:259, 371, 398; drone_app/lib/state/
    app_state.dart:92, 199, 216, 259, 286, 331, 370).
  - Демо‑данные создаются при старте и живут в том же файле БД, что и продовые данные (backend/main.py:39–90). Это
    смешивает окружения и чревато “мусорной” базой.
  - Встроенный симулятор дронов публично доступен и без защиты может генерировать нагрузку/подменять телеметрию
    (backend/drone_simulator.py:87–95).
  - Контракт клиента и сервера расходится: клиент передает start/end координаты в WS/HTTP, но сервер их игнорирует.
  - TelemetryIn требует eventId, но код пытается генерировать его при отсутствии. Сейчас запрос без eventId упадет с 422.

  Низкий/качество

  - main_old.py и тестовые скрипты в продовом репо — риск случайного запуска старой логики/конфузов при деплое (backend/
    main_old.py, backend/test_websocket.py).
  - В приложении хардкод 127.0.0.1:8000 для мобилки/десктопа; на реальных устройствах не работает без кастомной сборки
    (drone_app/lib/state/app_state.dart:24–41).
  - orderId генерируется клиентом случайно, возможны коллизии и подмена заказов (drone_app/lib/state/app_state.dart:221–
    224).
  - В репозитории лежат артефакты окружения/сборки (.venv, drone_app/build, backend/drone.db). Это ухудшает безопасность
    и воспроизводимость, и может утечь в прод.

  Вопросы/допущения

  - Не вижу инфраструктуры (TLS, WAF, rate‑limit, секреты, мониторинг). Если это в отдельном репо/конфиге, нужен аудит
    там.
  - Не вижу контрактов аутентификации/заказов/платежей: сейчас всё “фронт‑локально”.

  Если хочешь, могу предложить дорожную карту фиксов (без кода) или помочь реализовать критические блоки: auth, модель
  заказов, устойчивое хранение, observability, rate‑limit
